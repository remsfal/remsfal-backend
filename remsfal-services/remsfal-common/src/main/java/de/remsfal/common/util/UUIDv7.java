package de.remsfal.common.util;

import java.security.SecureRandom;
import java.util.UUID;

/**
 * Utility class for generating UUID version 7 (UUIDv7) as defined in
 * <a href="https://www.rfc-editor.org/rfc/rfc9562">RFC 9562</a>.
 *
 * <h2>What is UUIDv7?</h2>
 * <p>UUIDv7 is a time-ordered UUID that embeds a Unix millisecond timestamp in its
 * most significant 48 bits. This guarantees that UUIDs generated later always have
 * a lexicographically (and thus numerically) greater value than UUIDs generated
 * earlier, enabling natural chronological ordering without a separate timestamp
 * column.</p>
 *
 * <h2>Binary Layout</h2>
 * <pre>
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * ├─────────────────────────────────────────────────────────────────┤
 * │                  unix_ts_ms (48 bits)                           │
 * ├────────┬────────────────────────────────────────────────────────┤
 * │ 0 1 1 1│          rand_a (12 bits)                              │
 * ├──┬─────────────────────────────────────────────────────────────┤
 * │1 0│                rand_b (62 bits)                             │
 * └──────────────────────────────────────────────────────────────────┘
 *
 *  unix_ts_ms : 48-bit big-endian unsigned Unix epoch in milliseconds
 *  ver        :  4-bit version field set to 0b0111 (= 7)
 *  rand_a     : 12-bit pseudo-random data
 *  var        :  2-bit variant field set to 0b10 (RFC 4122 / RFC 9562)
 *  rand_b     : 62-bit pseudo-random data
 * </pre>
 *
 * <h2>Why UUIDv7 instead of UUIDv4?</h2>
 * <p>Standard {@link UUID#randomUUID()} (UUIDv4) is purely random and carries no
 * temporal information. In Cassandra, where rows within a partition are physically
 * ordered by their clustering column, using UUIDv4 as the clustering column results
 * in random physical ordering. UUIDv7 solves this by making the clustering order
 * match insertion time, enabling efficient {@code CLUSTERING ORDER BY (issue_id DESC)}
 * which returns the most recent rows first — without an extra {@code ORDER BY} clause
 * or a redundant {@code created_at} index.</p>
 *
 * <h2>Usage</h2>
 * <pre>{@code
 * // Generate a new time-ordered UUID
 * UUID id = UUIDv7.randomUUID();
 *
 * // UUIDs are chronologically comparable via natural ordering
 * UUID older = UUIDv7.randomUUID();
 * UUID newer = UUIDv7.randomUUID();
 * assert older.compareTo(newer) < 0; // older < newer
 *
 * // Extract the embedded creation timestamp
 * long createdAtMs = UUIDv7.extractTimestamp(id);
 * Instant createdAt = Instant.ofEpochMilli(createdAtMs);
 * }</pre>
 *
 * <h2>Future compatibility</h2>
 * <p>Starting with <strong>Java 26</strong>, UUIDv7 generation will be available
 * directly in the standard library via {@code UUID.generateTime7()} (JEP 487 /
 * JDK-8337519). Once the project upgrades to Java 26+, this utility class can be
 * replaced by the standard API.</p>
 *
 * @author Alexander Stanik [alexander.stanik@htw-berlin.de]
 * @see <a href="https://www.rfc-editor.org/rfc/rfc9562">RFC 9562 – UUIDs</a>
 * @see <a href="https://openjdk.org/jeps/487">JEP 487 – UUID (Java 26)</a>
 */
public final class UUIDv7 {

    private static final SecureRandom RANDOM = new SecureRandom();

    private UUIDv7() {
        // Utility class — not instantiable
    }

    /**
     * Generates a new time-ordered UUID (version 7).
     *
     * <p>The 48 most significant bits are filled with the current Unix epoch in
     * milliseconds, ensuring that every UUID generated later is lexicographically
     * greater than any UUID generated earlier (within the resolution of
     * {@link System#currentTimeMillis()}).
     * The remaining bits are filled with cryptographically strong random data.</p>
     *
     * @return a new UUIDv7 instance
     */
    public static UUID randomUUID() {
        long timestamp = System.currentTimeMillis();

        // Most significant 64 bits:
        // [48-bit unix_ts_ms][4-bit version = 0111][12-bit rand_a]
        long msb = (timestamp << 16)
                 | 0x7000L
                 | (RANDOM.nextLong() & 0x0FFFL);

        // Least significant 64 bits:
        // [2-bit variant = 10][62-bit rand_b]
        long lsb = (RANDOM.nextLong() & 0x3FFF_FFFF_FFFF_FFFFL)
                 | 0x8000_0000_0000_0000L;

        return new UUID(msb, lsb);
    }

    /**
     * Extracts the Unix epoch timestamp (in milliseconds) embedded in a UUIDv7.
     *
     * <p>This is the inverse of the timestamp encoding performed in
     * {@link #randomUUID()}. Passing a UUID that was not generated as UUIDv7
     * produces an undefined result.</p>
     *
     * @param uuid a UUID generated by {@link #randomUUID()}
     * @return the Unix epoch millisecond timestamp embedded in the UUID
     * @throws IllegalArgumentException if the UUID version is not 7
     */
    public static long extractTimestamp(final UUID uuid) {
        if (uuid.version() != 7) {
            throw new IllegalArgumentException(
                "Expected UUIDv7, but got version " + uuid.version());
        }
        // The upper 48 bits of msb hold the timestamp; shift right by 16 to recover.
        return uuid.getMostSignificantBits() >>> 16;
    }

}
